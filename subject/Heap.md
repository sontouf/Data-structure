# Heap
> 우선순위 큐를 구현하기 위해 만들어진 자료구조

## 우선순위 큐
- `우선순위 큐(priority queue)` : 요소들이 우선순위를 가져, 우선순위가 높은 데이터부터 먼저 나가는 큐
- `우선순위 큐의 사용` 
  - 시뮬레이션 시스템
  - 네트워크 트래픽 제어
  - 운영 체제에서의 작업 스케줄링


## 우선순위 큐의 종류
우선순위 큐는 요소를 삭제하는 기준에 따라 두 가지로 나눌 수 있다.

1. 최소 우선순위 큐: 가장 우선순위가 낮은 요소부터 삭제
2. 최대 우선순위 큐: 가장 우선순위가 높은 요소부터 삭제

여기서는 `최대 우선순위 큐`만을 다루자.

## 우선순위 큐의 연산

- `is_empty(우선순위 큐)`: 우선순위 큐가 비어있는지 검사한다.
- `insert(우선순위 큐, 요소)`: 우선순위 큐에 요소를 추가한다.
- `delete(우선순위 큐)`: 우선순위 큐에서 가장 우선순위가 높은 요소를 꺼내어 반환한다.
- `find(우선순위 큐)`: 우선순위 큐에서 가장 우선순위가 높은 요소를 (삭제없이) 반환한다.



## 우선순위 큐의 구현

우선순위 큐는 세 가지 자료규조를 사용해 구현할 수 있다.

1. 배열: 요소의 값이 우선순위를 표현
2. 연결리스트
3. 힙(heap)

이 중에서도 `힙`으로 구현하는 것이 가장 효율적이다.

| 방법                | 삽입    | 삭제    | 설명                                                         |
| ------------------- | ------- | ------- | :----------------------------------------------------------- |
| 순서없는배열        | O(1)    | O(n)    | 삽입: 우선순위를 고려하지 않고 삽입하므로 상수 시간에 가능하다. <br />삭제: 요소가 우선순위에 따라 정렬되어있지 않으므로 탐색에 O(n)의 시간복잡도가 필요하다. |
| 순서없는 연결리스트 | O(1)    | O(n)    | 삽입: 우선순위를 고려하지 않고 삽입하므로 상수 시간에 가능하다. <br />삭제: 요소가 우선순위에 따라 정렬되어있지 않으므로 탐색에 O(n)의 시간복잡도가 필요하다. |
| 정렬된 배열         | O(n)    | O(1)    | 삽입: 우선순위를 고려하여 삽입해야 하므로, 탐색에 O(n)의 시간복잡도가 필요하다. 또한 뒤의 데이터까지 뒤로 한 칸씩 미뤄야한다. |
| 힙                  | O(logn) | O(logn) | 밑에서 설명. 완전 이진트리의 특징.                           |



## 힙의 특징

- `완전이진트리(complete binary tree)`에 속한다.
- 이진 트리이므로 `이진 힙(binary heap)`이라고도 한다.
- 일종의 반(half) 정렬상태로, O(logn)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있도록 고안되었다.
- __배열__에 기반한 자료구조이다.



## 힙의 종류

![binary heap](https://user-images.githubusercontent.com/57662010/168427249-0949eb56-e549-4b04-8fab-fb7e5e215e7e.jpg)

힙은 부모와 자식의 키 값에 따라 두 종류로 나눌 수 있다.

1. __Max heap__: 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리이다.

   - 이때 가장 우선순위가 높은 노드는 가장 키 값이 큰 노드로, 루트 노드에 있다.

   ```
   부모 노드의 키 값 >= 자식 노드의 키 값
   ```

2. __Min heap__: 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리이다.

   - 이때 가장 우선순위가 높은 노드는 가장 키 값이 작은 노드로, 루트 노드에 있다.

   ```
   부모 노드의 키 값 <= 자식 노드의 키 값
   ```



## 힙의 구현

힙은 `배열`을 이용하여 구현할 수 있다.

- 완전 이진 트리에서 각 노드에 번호를 붙인다고 할 때, 이 번호를 배열의 인덱스로 생각할 수 있다.
- 부모 노드와 자식 노드의 인덱스를 찾기 쉽다. 단, 루트 노드의 번호가 1부터 시작하도록 구현해야 한다.

```
왼쪽 자식의 인덱스 = 부모인덱스 * 2
오른쪽 자식의 인덱스 = 부모인덱스 * 2 + 1
부모 인덱스 = 자식인덱스 / 2
```



#### insert

힙에 요소 `i`를 삽입하는 과정을 다음과 같다.

1. 요소를 트리에서 가장 하위 레벨의 최대한 왼쪽으로 삽입한다. 배열에서는 가장 뒤에 요소를 추가한다.
2. 힙의 성질을 만족할 때까지 부모 노드와 삽입한 노드를 교환한다. 이 과정에서 루트 노드에 도착하면 교환을 멈춘다.
   - 최대 힙의 경우 : 삽입한 요소가 부모보다 크다면 둘을 교환한다.
   - 최소 힙의 경우 : 삽입한 요소가 부모보다 작다면 둘을 교환한다.



#### delete

힙에서 요소를 삭제하는 과정은 다음과 같다.

1. 가장 운선순위가 높은 노드인 루트 노드를 삭제한다.
   - 최대 힙의 경우 : 가장 우선순위가 높은 노드, 곧 가장 키 값이 큰 노드(최대값) 은 루트 노드이다.
   - 최소 힙의 경우 : 가장 우선순위가 높은 노드, 곧 가장 키값이 작은 노드(최소값)은 루트 노드이다.
2. 트리에서 가장 하위 레벨의 가장 오른쪽에 있는 노드를 골라 루트 노드에 삽입한다. 배열에서는 가장 뒤에 있는 요소이다.
3. 힙의 성질을 만족할 때까지 삽입한 노드와 자식노드를 교환한다. 이 과정에서 가장 하위 레벨에 도착하면 교환을 멈춘다.
   - 최대 힙의 경우 : 삽입한 요소가 자식보다 작다면 둘을 교환한다.
   - 최소 힙의 경우 : 삽입한 요소가 자식보다 크다면 둘을 교환한다.



## 힙의 시간 복잡도

| 연산      | 시간복잡도 | 설명                                                         |
| --------- | ---------- | ------------------------------------------------------------ |
| insert(i) | O(logn)    | 최악의 경우 가장 마지막에 삽입한 요소가 루트 노드까지 올라가야 하므로 트리의 높이에 해당하는 수 (logn) 만큼 루프를 돌아야 한다. |
| delete()  | O(logn)    | 최악의 경우 루트에 삽입한 요소가 최하위 레벨까지 내려가야 하므로 트리의 높이에 해당하는 수(logn) 만큼 루프를 돌아야 한다. |
| find()    | O(1)       | 가장 우선순위가 높은 노드는 루트에 있는 노드이기 때문에 상수 시간에 접근할 수 있다. |



## 파이썬과 힙

파이썬의 heapq 는 최소 힙의 연산을 지원한다.

| 연산                         | 시간 복잡도 | 설명                                                      |
| ---------------------------- | ----------- | --------------------------------------------------------- |
| heapq.heapify(리스트)        | O(n)        | 리스트의 원소들을 최소 힙의 성질에 적합하도록 재배열한다. |
| heapq.heappush(리스트, 요소) | O(logn)     | 리스트에 요소를 삽입한다.                                 |
| heapq.heapop(리스트)         | O(logn)     | 리스트에서 가장 우선순위가 높은 요소를 삭제하고 반환한다. |



































source code

```python
from typing import Optional, TypeVar

T = TypeVar('T')

class ListNode:
    def __init__(self, val: T, next: Optional['ListNode'] = None):
        self.val = val
        self.next = next

class Stack:
    def __init__(self):
        self.top = None
    
    def is_empty(self) -> bool:
        return self.top is None

    def push(self, item: T):
        self.top = ListNode(item, self.top)

    def pop(self) -> Optional[T]:
        if self.is_empty():
            return None

        val = self.top.val
        self.top = self.top.next

        return val

    def peek(self) -> Option[T]:
        return None if self.is_empty else self.top.val
```

## 스택의 시간 복잡도
| 연산         | 시간 복잡도 | 설명                                                         |
| ------------ | ----------- | ------------------------------------------------------------ |
| push()       | O(1)        | `top`으로 가장 위에 있는 요소를 가리키므로 상수 시간에 삽입 연산이 가능하다. |
| pop()        | O(1)        | `top`으로 가장 위에 있는 요소를 가리키므로 상수 시간에 삭제 연산이 가능하다. |
| peek()       | O(1)        | `top`으로 가장 위에 있는 가리키므로 상수 시간에 접근할 수 있다. |
| search(item) | O(n)        | 연결 리스트로 구현되었으므로 상수 시간에 요소를 탐색할 수 없다. |

백준 9012번 괄호검사

## 파이썬과 스택

파이썬의 `리스트`는 스택의 연산을 지원한다.

| 연산               | 시간복잡도 | 설명                                                         |
| ------------------ | ---------- | ------------------------------------------------------------ |
| append(item)       | O(1)       | 가장 뒤에 요소를 삽입하므로 상수 시간에 삽입 연산이 가능하다. |
| pop()              | O(1)       | 가장 마지막에 있는 요소를 삭제하고 반환하므로 상수 시간에 삭제 연산이 가능하다. |
| stack[-1]          | O(1)       | 인덱스로 요소에 접근하므로 가장 위에 있는 요소에 상수 시간에 접근할 수 있다. |
| find(i) / index(i) | O(n)       | 배열의 모든 요소를 탐색해야 한다.                            |
