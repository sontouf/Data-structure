# $Big-O$ and Complexcity
`수행시간, 복잡도`

> 알고리즘의 성능을 분석하는 데 두 가지 방법이 있다.

- 알고리즘의 수행시간을 측정하기
- 알고리즘의 복잡도를 분석하기


`알고리즘의 수행 시간을 측정`하려면, 알고리즘을 실제로 구현하고 수행시간을 측정해야 한다. 이 경우 하드위어나 구현에 사용한 프로그래밍 언어에 따라 수행 시간이 달라질 수 있다.

한편, `알고리즘의 복잡도를 분석`하여 성능을 측정하는 경우에는 위 방법과 달리 알고리즘을 구현하거나 수행할 필요가 없당. 알고리즘의 복잡도 분석은 다음과 같이 두 가지로 나뉜다.

- 알고리즘의 시간 복잡도 측정
- 알고리즘의 공간 복잡도 측정

## GOAL
`빠르게, 최소한으로`
> 알고리즘에서 결과가 도출될 떄까지 실행에 걸리는 시간도 짧고 메모리같은 자원을 덜 사용하는 것

## Condition
`동일한 하드웨어, 환경`
> 당연한 얘기지만 서로 다른 알고리즘을 비교하려면 반드시 동일한 하드웨어를 사용한 상태에서 알고리즘의 실행 시간을 측정해야 한다. 또한 측정 시 사용되는 소프트웨어의 환경도 고려되어야 한다. `C` 언어와 같은 컴파일 언어를 사용한 경우는 `베이직`과 같은 인터프리터 언어를 사용한 경우보다 실행속도가 빠르다.

## Time Complexctiy
`연산 횟수`
> 알고리즘을 수행하는 데 연산들이 몇 번 이루어지는 지를 숫자로 표기한 것이다.
- 이때 연산의 종류는 산술, 대입, 비교, 이동을 뜻한다.

## O(n)

`빅오 표기법`
> 빅오 표기법(big-oh notation)이란, 상대적으로 불필요한 연산을 제거하여 알고리즘의 분석을 조금 더 간편하게 해준다.

알고리즘의 수행 시간은 상한($O$, upper bound), 하한($\mathit\Omega$, lower bound), 평균($\mathit\Theta$)으로 나누어볼 수 있다. 이중 상한에 주목하여 빅오 표기법을 사용한다. `빅오 표기법(big-O notation)`은 
에 대한 차수식에서 계수를 무시하고 최고차항에 대해서만 표기하는 것이다.

어떤 알고리즘의 입력의 크기 n에 대해 $3n^2+n+1$
만큼 시간이 걸린다고 하자. 이 알고리즘을 빅오표기법으로 나타내면 $O(n^2)$이다.

## Space Complexcity
`resource space`
> 프로그램을 실행하고 완료하는 데 필요한 자원 공간의 양이다.
```
재귀호출 같이 스택같은 메모리에 쌓이는 것을 신경쓰는 문제는 공간복잡도랑 관련있다.
```

## Time Complexcity vs Space Complexcity
`Time`
> 물론 둘다 잘 고려하면 좋지만 요즘 같은 대용량 시대에는 시간복잡도 위주로 판단한다. 시간과 공간은 반비례적인 경향도 있고 시간복잡도만 괜찮다면 공간은 어느정도 이해해준다. 