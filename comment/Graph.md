# Graph

- 그래프(graph) : 연결된 객체 간의 관계를 나타내는 자료구조
- 그래프는 `정점` 과 `간선` 들의 집합이다.
    - 정점(node 혹은 vertex) : 그래프에서 객체를 의미한다.
    - 간선(edge 혹인 link) : 그래프에서 객체를 연결하는 관계를 의미한다.
- 부분 그래프(subgraph) : 어떤 그래프에 대하여 정점의 집합과 간선의 집합이 있을 때, 이 집합의 부분 집합으로 이루어진 그래프를 의미한다.

## 그래프의 종류
### 무방향 그래프와 방향 그래프
그래프는 그래프를 이루는 간선에 방향이 있는지, 없는 지에 따라 `방향 그래프` 와 `무방향 그래프` 로 나눌 수 있다.
- 무방향 그래프 (undirectedd graph)
    - 방향이 없는 간선(undirected edge) 만 사용한다.
    - 간선을 통하여 양방향으로 갈 수 있다.
    - 정점 `A` 와 `B` 를 잇는 간선은 `(A, B)` 로 표기한다.
    - `(A, B) == (B, A)`

- 방향 그래프(directed graph)
  - 방향이 있는 간선(directed edge) 만 사용한다.
  - 간선을 토앟여 한쪽 방향으로만 갈 수 있다.
  - 정점 `A` 에서 `B`로 연결되는 간선은 `<A, B>` 로 표기한다.
  - `<A, B> != <B, A>`

### 가중치 그래프

- 가중치 그래프 (weighted graph)
  - 간선에 비용(cost)나 가중치(weight)가 할당되어 있다.
  - 네트워크(network) 라고도 한다.

### 연결 그래프와 비연결 그래프

`무방향 그래프` 는 정점의 연결 정도에 따라 `연결 그래프`와 `비연결 그래프` 로 나눌 수 있다.

- 연결 그래프(connected graph) : 어떤 무방향 그래프에 대하여, 그래프에 있는 모든 정점 쌍에 대하여 경로가 존재한다.

  - 예 : 트리, 완전 그래프

- 비연결 그래프 : 연결 그래프가 아닌 무방향 그래프

  - 컴포넌트(connected component) : 비연결 그래프에서, 연결된 정점들끼리의 집합을 의미한다.

  ![connected component](https://user-images.githubusercontent.com/57662010/164989596-c6badc3f-1a80-4c9b-ad35-820a76d8cf5d.jpg)

위 비연결 그래프에서 컴포넌트는 2개이다.

### 트리

- 트리(tree)
  - 사이클을 가지지 않는 연결 그래프 혹은 사이클을 가지지 않는 방향 그래프
  - `n` 개의 정점, `n-1` 개의 간선

### 완전 그래프

- 완전 그래프(complete graph) : 모든 정점이 연결되어 있는 그래프
  - 연결 그래프에 속한다.
  - `n` 개의 정점, `n * (n - 1) / 2` 개의 간선

### 순환 그래프와 비슷한 그래프

그래프에 `사이클`이 있는지 없는지에 따라 `순환 그래프`와 `비순환 그래프`로 나눌 수 있다.

- 순환 그래프(cycle graph) : 사이클이 있는 그래프
- 비순환 그래프(acylic graph) : 사이클이 없는 그래프

### 인접 정점과 차수

- 인접 정점(adjacent vertex) : 하나의 정점에 대하여, 간선으로 직접 연결된 정점
- 무방향 그래프의 차수(degree) : 하나의 정점에 대하여, 인접 정점의 수
- 방향 그래프의 차수(degree)
  - 진입 차수 (in-degree) : 하나의 정점에 대하여, 해당 정점으로 들어오는 간선의 수
  - 진출 차수 (out-degree) : 하나의 정점에 대하여, 해당 정점에서 나가는 간선의 수

### 그래프의 경로

- 경로 (path) : 어떤 그래프에 대하여, 한 정점에서 다른 정점(자신 포함) 으로 가는 간선이 존재하는 경우, 두 정점 사이에 겨올가 있다고 한다. 이때 경로는 정점과 정점 사이에 거치는 정점을 나열한 것이다.
- 무방향 그래프에서의 경로
  - 정점의 나열 : `A`, `B`, `C`, ... , `Y`, `Z`
  - 정점들 간에 반드시 간선 `(A, B)` , `(B, C)`, ... , `(Y, Z)` 이 존재한다.
- 방향 그래프에서의 경로
  - 정점의 나열 : `A`, `B`, `C`, ... , `Y`, `Z`
  - 정점들 간에 반드시 간선 `<A, B>` , `<B, C>`, ... , `<Y, Z>` 이 존재한다.
- 경로의 길이 (length) : 경로를 구성하는 데 사용된 간선의 수

### 단순 경로와 사이클

- 단순 경로(simple path) : 경로 중에서 반복되는 간선이 없는 경로
- 사이클(cycle) : 단순 경로 중 시작 정점과 종료 정점이 동일한 경로

### 그래프의 표현 방법

그래프는 정점에 대한 인접 정점들로 표현한다. 행렬을 이용하여 `인접 행렬` 이나 연결 리스트를 사용하여 `인접 리스트` 로 나타낼 수 있다.

### 인접 행렬 (adjacent matrix)

- 그래프에 정점의 개수가 `N`개라면 `N * N` 행렬로 표현된다.

```python
adj = [[0] * N for _ in range(N)]
```

- 두 정점 `A` 와 `B`를 잇는 간선 `<A, B>`가 존재한다면 `arr[A][B] = 1 `, 그렇지 않다면 `arr[A][B]= 0 `이다.
- 무방향 그래프의 인접 행렬은 대칭이다.
  - 두 정점 `A` 와 `B` 에 대하여 간선 `<A, B>` 와 `<B, A>` 가 모두 존재한다.
  - 따라서 모든 임의의 정점 `A`, `B` 에 대하여 `arr[A][B] == arr[B][A]`가 성립한다.

### 무방향 그래프 구현하기

인접행렬로 방향이 없는 그래프 구현하기

```python
# 방향이 없는 그래프에 정점이 0과 1만 존재할 경우
adj = [[0] * 2 for _ in range(2)]

# (0,1) 표현하기
adj[0][1] = 1
adj[1][0] = 1
```

### 방향 그래프 구현하기

인접행렬로 방향이 있는 그래프 구현하기

```python
# 방향이 있는 그래프에 정점이 0과 1만 존재할 경우
adj = [[0] * 2 for _ in range(2)]

# (0,1) 표현하기
adj[0][1] = 1
```

### 인접 행렬의 공간 복잡도

- 그래프에 노드가 `N` 개라면, 요소가 `N`개인 배열이 `N` 개 필요하므로 `O(N^2)` 의 공간 복잡도를 요구한다.

### 장점과 단점

- 장점 : 정점 `V`와 `W`에 대하여, 두 정점이 연걸되어 있는지는 `graph[v][w] == 1`로 상수 시간에 알 수 있다.
- 단점 : 인접 리스트보다 더 높은 공간 복잡도를 요구한다.



### 인접 리스트(adjacent list)

- 각각의 정점은 자신의 인접 정점들을 노드로 가진 연결 리스트르의 헤드 노드가 된다.
- 파이썬의 딕셔너리를 사용하면 `키`는 `정점`으로, `값`은 `인접 정점들의 리스트`로 표현한다.

```python
import collections
adj = collections.defaultdict(list)
```

- 두 정점 `A`와 `B`를 잇는 간선 `<A, B>` 가 존재한다면 `adj[A].append(B)`를 한다.

### 무방향 그래프 구현하기

- 인접 리스트로 방향이 없는 그래프 구현하기

```python
# 방향이 없는 그래프에 정점이 0과 1만 존재할 경우
adj = collections.defaultdict(list)

# (0, 1) 표현하기
adj[0].append(1)
adj[1].append(0)
```

### 방향 그래프 구현하기

- 인접 리스트로 방향이 있는 그래프 구현하기

```python
# 방향이 있는 그래프에 정점이 0과 1만 존재할 경우
adj = collections.defaultdict(list)

# <0, 1> 표현하기
adj[0].append(1)
```

### 인집리스트의 공간 복잡도

- 그래프에 노드가 `N`개이고 간선의 수가 `E`개라면, 각 요소당 `인접 정점의 수`만큼의 리스트를 필요로 하므로 `O(N+E)`의 공간 복잡도를 요구한다.

### 장점과 단점

- 장점 : 인접 행렬보다 낮은 공간 복잡도를 요구한다.
- 단점 : 정점 `V`와 `W`에 대하여, 두 정점이 연결되어 있는지는 `w in graph[v]` 연산으로 알 수 있으므로 `O(n)` 시간 복잡도를 요구한다.

